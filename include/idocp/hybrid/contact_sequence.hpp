#ifndef IDOCP_CONTACT_SEQUENCE_HPP_
#define IDOCP_CONTACT_SEQUENCE_HPP_ 

#include <vector>
#include <deque>

#include "idocp/robot/robot.hpp"
#include "idocp/robot/contact_status.hpp"
#include "idocp/robot/impulse_status.hpp"
#include "idocp/hybrid/discrete_event.hpp"


namespace idocp {

///
/// @class ContactSequence
/// @brief The sequence of contact status and discrete events (impulse and lift). 
///
class ContactSequence {
public:
  ///
  /// @brief Constructor. 
  /// @param[in] robot Robot model. Must be initialized by URDF or XML.
  /// @param[in] max_num_events Maximum number of each discrete events 
  /// (impulse and lift). 
  ///
  ContactSequence(const Robot& robot, const int max_num_events);

  ///
  /// @brief Default constructor. 
  ///
  ContactSequence();

  ///
  /// @brief Destructor. 
  ///
  ~ContactSequence();

  ///
  /// @brief Default copy constructor. 
  ///
  ContactSequence(const ContactSequence&) = default;

  ///
  /// @brief Default copy assign operator. 
  ///
  ContactSequence& operator=(const ContactSequence&) = default;

  ///
  /// @brief Default move constructor. 
  ///
  ContactSequence(ContactSequence&&) noexcept = default;

  ///
  /// @brief Default move assign operator. 
  ///
  ContactSequence& operator=(ContactSequence&&) noexcept = default;

  ///
  /// @brief Set the contact status over all of the time stages uniformly. Also, 
  /// disable discrete events over all of the time stages.
  /// @param[in] contact_status Contact status.
  ///
  void setContactStatusUniformly(const ContactStatus& contact_status);

  ///
  /// @brief Push back the discrete event. Contact status after discrete event 
  /// is also appended according to discrete_event. 
  /// @param[in] discrete_event Discrete event.
  ///
  void pushBackDiscreteEvent(const DiscreteEvent& discrete_event);

  ///
  /// @brief Push back the discrete event that is automatically generated by
  /// last contact status of this object and contact_status.
  /// @param[in] contact_status Contact status.
  /// @param[in] event_time Time of the discrete event.
  ///
  void pushBackDiscreteEvent(const ContactStatus& contact_status, 
                             const double event_time);

  ///
  /// @brief Pop back the discrete event. Contact status after discrete event 
  /// is also removed. 
  ///
  void popBackDiscreteEvent();

  ///
  /// @brief Pop front the discrete event. Contact status before the front 
  /// discrete event is also removed. 
  ///
  void popFrontDiscreteEvent();

  ///
  /// @brief Shift the impulse event. 
  /// @param[in] impulse_index Index of the impulse event. Must be non-negative
  /// and less than numImpulseEvents().
  /// @param[in] event_time Event time after shift.
  ///
  void shiftImpulseEvent(const int impulse_index, const double event_time);

  ///
  /// @brief Shift the lift event. 
  /// @param[in] lift_index Index of the lift event. Must be non-negative
  /// and less than numLiftEvents().
  /// @param[in] event_time Event time after shift.
  ///
  void shiftLiftEvent(const int lift_index, const double event_time);

  ///
  /// @brief Set the contact points to contact statsus with specified contact  
  /// phase. Also set the contact points of the discrete event just before the  
  /// contact phase.
  /// @param[in] contact_phase Contact phase.
  /// @param[in] contact_points Contact points.
  ///
  void setContactPoints(const int contact_phase, 
                        const std::vector<Eigen::Vector3d>& contact_points);

  ///
  /// @brief Returns number of impulse events. 
  /// @return Number of impulse events.
  ///
  int numImpulseEvents() const;

  ///
  /// @brief Returns number of lift events. 
  /// @return Number of lift events.
  ///
  int numLiftEvents() const;

  ///
  /// @brief Returns number of discrete events, i.e., sum of 
  /// numImpulseEvents() and numLiftEvents().
  /// @return Number of discrete events.
  ///
  int numDiscreteEvents() const;

  ///
  /// @brief Returns number of contact phases. 
  /// @return Number of contact phases.
  ///
  int numContactPhases() const;

  ///
  /// @brief Getter of the contact status. 
  /// @param[in] contact_phase Index of contact status phase.
  /// @return const reference to the contact status.
  ///
  const ContactStatus& contactStatus(const int contact_phase) const;

  ///
  /// @brief Getter of the impulse status. 
  /// @param[in] impulse_index Index of impulse event.
  /// @return const reference to the impulse status.
  ///
  const ImpulseStatus& impulseStatus(const int impulse_index) const;

  double impulseTime(const int impulse_index) const;

  double liftTime(const int lift_index) const;

  bool isImpulseEvent(const int event_index) const;

  bool isLiftEvent(const int event_index) const;

private:
  int max_num_events_, num_impulse_events_, num_lift_events_;
  std::vector<ContactStatus> contact_status_sequence_;
  std::vector<DiscreteEvent> impulse_event_sequence_, lift_event_sequence_;
  std::deque<bool> is_impulse_event_;

  void popBackImpulseEvent();

  void popBackLiftEvent();

  void popFrontImpulseEvent();

  void popFrontLiftEvent();

};

} // namespace idocp 

#include "idocp/hybrid/contact_sequence.hxx"

#endif // IDOCP_CONTACT_SEQUENCE_HPP_ 